## 02장 - 리액트 핵심 요소 살펴보기

### 2.1 JSX란?

JS의 표준이 아니기에 트랜스파일러를 거쳐야하고 리액트의 전유물도 아니다.

JSX는 HTML을 JS 내부에 표현하는 것이 유일한 목적이 아니다. 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환하는 데 초점을 두고 있다.

### 2.2 가상 DOM과 리액트 파이버

DOM과 브라우저 렌더링 과정 살펴보기

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 위 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드 후 파싱해 CSS노드로 구성된 트리(CSSOM)를 만든다.
4. 브라우저는 만든 DOM 노드를 순회한다. (사용자 눈에 보이는 노드만 ← 트리 분석 과정 빠르게)
5. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 CSS 스타일 정보를 노드에 적용한다. 이때 DOM에 CSS를 적용하는 과정은 크게 레이아웃과 페인팅으로 나눌 수 있다.
   - 레이아웃: 각 노드가 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정으로 이 과정을 거치면 반드시 페인팅 과정도 거친다.
   - 페인팅: 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

렌더링 이후에 사용자의 인터렉션으로 웹페이지가 변경되는 상황이 SPA에서 더욱 많아졌다. 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 수고스럽고 결과적으로 DOM의 결과물을 아는것이 중요하다. 이러한 문제점을 가상 DOM이 해결해준다. DOM 계산을 브라우저가 아닌 메모리에서 처리하고 실제 변경의 준비가 끝나면 리액트는 실제 브라우저의 DOM에 반영한다. 여러 번 발생했을 렌더링 과정을 최소화하기에 부담을 덜 수 있다.

### 2.23 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트의 핵심 원리 중 하나는 컴포넌트의 상태(state)나 속성(props)이 변경되면 리렌더링이 발생하고, 이때 새로운 가상 DOM 트리가 생성된다. 새로운 가상 DOM 트리와 이전 가상 DOM 트리를 비교하여 변경된 부분만을 실제 DOM에 반영하고 이를 통해 성능을 향상시키고 불필요한 렌더링을 방지한다.

리액트의 Fiber 아키텍처는 이러한 가상 DOM과 렌더링 과정 최적화를 가능하게 해준다. Fiber는 특히 비동기적으로 작업을 수행할 수 있는 기능을 제공하며, 복잡한 컴포넌트 트리에서도 빠르게 렌더링할 수 있도록 도와준다.

파이버 재조정자가 가상 돔과 실제 돔을 비교해서 변경 사항을 수집하고 변경 관련 정보를 가진 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

파이버는 리액트에서 관리하는 JS 객체이고 하나의 작업 단위로 구성 되어있다. 파이버는 리액트 요소와 달리 렌더링 시 새로 생성되지 않고 가급적 재사용된다. 리액트 컴포넌트의 정보를 1:1로 가진 것이 파이버라고 볼 수 있다. 파이버는 state변경, 메서드 실행, DOM 변경이 필요한 시점 등에 실행된다. 리액트는 값을 가진 UI(문자열, 객체, 배열 등)를 관리하는 라이브러리라고 할 수 있다.

리액트 내부의 파이버와 재조정자가 DOM을 변경하는 작업과 무엇이 변경되었는지 파악하고 관리하는 것을 내부 알고리즘을 통해 관리해 줌으로써 대규모 웹 애플리케이션을 효율적으로 유지보수하고 관리할 수 있게 된 것이다.

### 2.3 클래스형 컴포넌트와 함수형 컴포넌트

클래스형 컴포넌트의 생명주기 메서드

- 마운트: 컴포넌트가 생성되는 시점
- 업데이트: 이미 생성된 컴포넌트의 내용이 변경되는 시점
- 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점

`render()`

이 함수는 UI를 렌더링하기 위해서 쓰인다. 그리고 이 렌더링은 마운트와 업데이트 과정에서 일어난다. 주의할 점은 render() 함수는 항상 순수해야 하며 부수 효과가 없어야 한다. 따라서 state를 직접 업데이트하는 this.setState를 호출하면 안 된다. state를 변경하는 일은 클래스형 컴포넌트의 메서드나 다른 생명주기 메서드 내부에서 발생해야 한다.

왜 함수형 컴포넌트에 훅을 도입한 새로운 패러다임으로 넘어갔을까?

- 데이터의 흐름을 추적하기 어렵다. 여러 다른 메서드에서 state의 업데이트가 일어날 수 있으며, 메서드의 순서가 강제돼 있는 것이 아니기 때문에 가독성이 떨어진다. 생명주기 메서드의 순서와 상관없이 코드가 작성돼 있을 수 있다.
- 내부 로직의 재사용이 어렵다. 중복되는 로직을 재사용하고 싶다고 가정한다면 상속해서 중복 코드를 관리 할 수 있지만 상속되고 있는 클래스의 흐름을 쫓아야 하기 때문에 복잡도가 증가한다. 고차 컴포넌트로 감싸거나 props를 넘겨주는 방식도 있지만 공통 로직이 많아질수록 이를 감싸는 고차 컴포넌트 내지는 props가 많아지는 wrapper hell에 빠질 위험이 커진다.

### 2.3.2 함수형 컴포넌트

리액트 16.8 버전 이전에는 단순히 무상태 컴포넌트를 구현하기 위한 수단이었지만 함수형 컴포넌트에서 사용 가능한 훅이 등장하면서 입지가 바뀌었다.

클래스형과 비교하면 render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요가 없고 state는 객체가 아닌 각각의 원시값으로 관리되어 사용하기 더욱 편해졌다. 렌더링하는 코드인 return에서도 굳이 this를 사용하지 않아도 props와 state에 접근할 수 있게 됐다.

생명주기 메서드의 부재

함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수이다. 반면 클래스형 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 자바스크립트 클래스이다. 즉, 생명주기 메서드는 React.Component에서 오는 것이기 때문에 함수형 컴포넌트에서는 생명주기 메서드를 사용할 수 없다.

함수형 컴포넌트는 useEffect 훅을 통해 생명주기 메서드를 비슷하게 구현할 수 있다. 그러나 useEffect는 생명주기를 위한 훅이 아니고 state를 활용해 동기적으로 부수 효과를 만드는 메커니즘이다.

### 2.4 렌더링은 어떻게 일어나는가?

브라우저에서의 렌더링이란 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다.

리액트에서의 렌더링은 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

### 2.4.2 리액트의 렌더링이 일어나는 이유

1. 최초 렌더링: 사용자가 처음 애플리케이션에 진입하면 최초 렌더링을 수행
2. 리렌더링: 최초 렌더링 이후로 발생하는 모든 렌더링을 의미.

- `useState()`의 두 번째 배열 요소인 setter가 실행되는 경우 (state 업데이트)
- `useReducer()`의 두 번째 배열 오소인 dispatch가 실행되는 경우
- 컴포넌트의 key props가 변경되는 경우 (리액트에서 key는 어떤 컴포넌트가 변경이 있는지 구별해야 하는데, 같은 컴포넌트인지 구별하는 값이 key이다)
- 부모로부터 전달받는 값인 props가 달라지면 자식 컴포넌트에서도 변경이 필요하므로 리렌더링
- 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다.

### 2.4.3 리액트의 렌더링 프로세스

렌더링이 어떤 과정을 거쳐 수행하는지 살펴보자. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 여기서 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 함수형 컴포넌트는 `FunctionComponent()` 자체를 호출한 뒤에 결과물을 저장한다. JSX 문법으로 구성된 렌더링 결과물을 자바스크립트로 컴파일 되면서 `React.createElement()` 를 호출하는 구문으로 변환된다.

이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집하고 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 수집하고 리액트의 재조정 과정을 통해 계산한다.

리액트의 렌더링은 두 단계로 분리되어 실행된다.

- 렌더: 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
- 커밋: 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

렌더링 하는 작업에서 상위 컴포넌트에서 렌더링을 발생시키는 작업이 일어나면 하위 모든 컴포넌트의 리렌더링을 트리거한다. 업데이트가 필요한 컴포넌트로 체크되지 않아도(자식) 부모가 렌더링되면 자식이 렌더링 된다.

자식에게 `memo`를 추가하면 렌더 단계에서 컴포넌트 비교를 거쳤지만 `memo`로 선언했기에 props가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된다.

### 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

리액트의 API중 `useMemo`, `useCallback` 훅과 고차 컴포넌트인 `memo`는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

메모이제이션도 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업과 결과물을 저장해두었다가 다시 꺼내와햐 한다는 두 가지 비용이 있다. 리렌더링 비용보다 저렴할 지는 상황에 따라 다를 것이다. 그렇기에 섣부른 최적화는 항상 경계해야 한다.

해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 심지어 자식 컴포넌트 또한 많이 가지고 있다면 메모이제이션 방법을 사용하는것이 성능에 도움이 된다. 이 때 선택지는 두 가지 이다.

- memo를 컴포넌트의 사용에 따라 일부에만 적용 → 이상적이나 현실적으로 힘듬
- memo를 일단 그냥 다 적용(memo를 안했을 때 치러야 할 잠재적인 위험 비용이 더 큼)

잠재적인 위험 비용 → 렌더링, 복잡한 내부 로직 재실행, 앞선 두가지가 자식 컴포넌트에서 반복, 리액트가 구 트리와 신규 트리를 비교하는 비용

리렌더링이 발생될 때 모든 객체는 재생성되고 결과적으로 참조가 달라지게 된다. 이 달라진 참조의 값을 어디서든 쓰지 않으면 문제 될 건 없지만 `useEffect`와 같은 의존성 배열에 쓰이면 변경된 참조로 인해 다른 쪽에도 영향을 미치게 될 것이다. 이럴 때 useMemo를 이용하면 참조의 투명성을 유지할 수 있다.
