# 15장 웹사이트 보안을 위한 리액트와 웹페이지 보안 이슈

웹 사이트의 성능만큼이나 중요한 것이 바로 웹사이트의 보안이다. 개발자들은 웹 사이트를 완성도 있게 만들고 충분한 성능을 내는 것과 동시에 외부의 위협에도 안전한 웹 사이트를 만들어야 할 책임감을 지녀야한다.

프론트엔드에서 해야 할 일이 많아질수록 코드의 규머 역시 증가하며, 필연적으로 보안 취약점에 노출될 확률도 증가한다. 보안 이슈는 라이브러리나 프레임워크가 알아서 해줄 수 없기 때문에 개발자 스스로가 신경써야 할 부분이다.

## 크로스 사이트 스크립팅(XSS)

Cross-Stie Scripting, XSS란 웹 사이트 개발자가 아닌 제 3자가 웹사이트에 악성 스크립트를 삽입해 실행할수 있는 취약점을 의미한다. 일반적으로 사용자가 웹사이트에 입력을 할 수 있고, 이 입력을 다른 사용자에게 보여줄 수 있는 경우에 발생한다.

스크립트가 실행될 수 있다면 웹사이트 개발자가 할 수 있는 모든 일을 할 수 있으며, 쿠키를 획득해 사용자의 로그인 세션을 탈취하거나 사용자의 데이터를 변경하는 등의 위험이 있다. 리액트에서는 XSS가 어떤 방식으로 발생될 수 있을까?

### dangerouslySetInnerHTML prop

dangerouslySetInnerHTML은 특정 브라우저 DOM의 innerHTML을 특정한 내용으로 교체할 수 있음을 의미한다. dangerouslySetInnerHTML의 위험성은 입력으로 받을 수 있는 문자열에 제한이 없다는 것이다.

### useRef를 활용한 직접 삽입

DOM에 직접 내용을 삽입할 수 있는 방법으로 useRef가 있다. useRef를 바탕으로 직접 DOM에 접근할 수 있으므로 innerHTML을 통해 스크립트를 삽입하면 동일한 보안 문제가 발생한다. 

### 리액트에서 XSS 문제를 피하는 방법

XSS 이슈를 피하는 확실한 방법은 제3자가 삽입할 수 있는 HTML을 안전한 HTML 코드로 한 번 치환하는 것이다. 직접 구현할 수도 있지만 npm에서 제공하는 라이브러리를 사용해 치환할 수 있다. 이러한 치환 과정을 세니타이즈, 이스케이프라고 부른다. 예를 들어 허용할 태그와 목록을 만들어 둘 수 있다.

또 단순히 데이터를 보여줄 때 뿐만 아니라 사용자가 콘텐츠를 저장할 때도 한번 이스케이프(치환) 과정을 거치는 것이 안전하다. 애초에 XSS 위험성이 있는 콘텐츠를 데이터베이스에 저장하지 않는 것이 도움이 되며, 한번 이스케이프하면 그 뒤로 보여줄 때마다 일일이 이스케이프 과정을 거치지 않아도 되므로 효율적이다. 

그리고 단순히 게시판과 같이 사용자 입력이 없는 웹사이트에서도 XSS 문제는 충분히 발생할 수 있다.

따라서 개발자는 자신이 작성한 코드가 아닌 query, GET 파라미터, 서버에 저장된 사용자가 입력된 데이터등 외부에 존재하는 모든 코드를 위험한 코드로 간주하고 이를 적절하게 처리하는 것이 좋다.

## getServerSideProps와 서버 컴포넌트를 주의하자

서버에는 일반 사용자에게 노출되면 안 되는 정보들이 담겨 있기 때문에 클라이언트에 정보를 내려줄 때는 조심해야 한다. getServerSideProps가 반환하는 props 값은 모두 사용자의 HTML에 기록되고 전역변수로 등록되어 스크립트로 충분히 접근 가능하다. 따라서 반드시 필요한 값으로만 철저하게 제한되어야 한다.

## <a> 태그의 값에 적절한 제한을 둬야 한다

<a> 태그에 자바스크립트 코드를 넣어 이벤트 핸들러를 실행시키는 용도로 사용할 수 있다. <a> 태그는 반드시 페이지 이동이 있을 때만 사용하는 것이 좋다.

또한 <a> 태그에 사용자가 입력한 주소를 넣을 수 있다면 보안 이슈로 이어질 수 있다. 따라서 href에 들어갈 수 있는 값을 제한해야한다. 

## HTTP 보안 헤더 설정하기

HTTP 보안 헤더란 브라우저가 렌더링하는 내용과 관련된 보안 취약점을 미연에 방지하기 위해 브라우저와 함께 장동하는 헤더를 의미한다.

### Strict-Transport-Security

HTTPdml Stric-Transport-Security 응답 헤더는 모든 사이트가 HTTPS를 통해 접근해야 하며, 만약 HTTP로 접근하는 모든 시도는 HTTPS로 변경되게 한다. 

### X-XSS-Protection

현재 사파리와 구형 브라우저에서만 제공되는 기능이다. 이 헤더는 XSS 취약점이 발견되면 페이지 로딩을 중단하는 헤더다.

### X-Frame-Options

X-Frame-Options는 페이지를 frame, iframe, embecd, object 내부에서 렌더링을 허용할지를 나타낼 수 있다. iframe으로 열리는 페이지를 사용자가 실제 페이지라고 오해할 수도 있고 공격자는 이를 이용해 사용자 정보를 탈취할 수 있다. X-Frame-Options는 외부에서 자신의 페이지를 삽입되는 것을 막아주는 헤더다.

### Permissions-Policy

Permissions-Policy는 웹 사이트에서 사용할 수 있는 기능과 사용할 수 없는 기능을 명시적으로 선언하는 헤더다. 개발자는 다양한 브라우저의 기능이나 API를 선택적으로 활성화하거나 필요에 따라서는 비활성화 할 수 있다.

이 헤더를 활용해 XSS가 발생한다고 하더라도 사용자에게 피칠 수 있는 악영향을 제한할 수 있게된다.

### X-Content-Type-Options

Content-Type 헤더에서 제공하는 데이터 유형이 브라우저에 의해 임의로 변경되지 않게 하는 헤더다. 즉 text/css 헤더가 없는 파일은 브라우저가 임의로 CSS로 사용할 수 없으며, text/javascript와 같은 헤더가 없는 파일은 자바스크립트로 해석할 수 없다. 즉 웹서버가 브라우저에 강제로 파일을 읽는 방식을 지정하는 헤더다.

### Referrer-Policy

Referrer는 현재 요청을 보낸 페이지의 주소가 나타난다. 만약 링크를 통해 들어왔다면 해당 링크를 포함하고 있는 페이지 주소가, 다른 도메인 요청을 보낸다면 해당 리소스를 사용하는 페이지의 주소가 포함된다. Referrer-Policy 헤더는 이 Referrer 헤더에서 사용할 수 있는 데이터를 나타낸다. 

scheme(프로토콜), hostname(호스트명), port의 조합을 출처라고 말하는데, 두 주소를 비교할 때 same-origin인지 cross-origin인지 구별할 때 사용할 수 있다. 세 가지 요소가 완전히 같은 경우, 포트가 명시적으로 작성되어 있지 않지만 기본 포트를 사용하는 경우 same-origin으로 판단하며 나머지 모든 경우는 corss origin으로 판단한다.

이 헤더에는 Referrer 헤더에 들어갈 출처의 범위를 지정할 수 있다.

### Content-Security-Policy

콘텐츠 보안 정책(CSP)는 XSS 공격이나 데이터 삽입 공격과 같은 다양한 보안 위협을 막기위해 설계 됐다.

- src 속성에서 가져올 소스를 제한할 수 있다.
- form-action으로 폼 양식으로 제출할 수 있는 URL을 제한할 수 있다.